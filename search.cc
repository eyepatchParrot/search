#include <cmath>
#include <tuple>
#include <numeric>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <assert.h>
#include <cstdio>
#include <vector>
#include <x86intrin.h>
#include <immintrin.h>
#include <algorithm>
#include <time.h>

// could we improve binary search by dividing the tree into fixed size chunks
// and looking at the ends of the chunks? This would add additional comparisons
// but might allow us to take advantage of cache lines and pre-fetching

// TODO remember that integer type matters. Parameterize?
typedef uint64_t ll;

struct RunStats {
  int sumSteps1, sumSteps2;
  int maxSteps1, maxSteps2;
  //  ll maxV;
};

struct TestStats {
  std::string name;
  std::vector<RunStats> runStats;
  std::vector<std::tuple<ll, int> > cyclesByIx;
};

struct Search {
  //  int ix;
  int ix, steps1, steps2;
};

std::vector<ll> input = {
  5453103210751120 ,18682532661094687 ,26146418696843751 ,45621802431669312 ,53410435623948054 ,57935348792086135 ,62247773627814510 ,62916409522023922 ,82939928517356026 ,90828485468577193 ,105018297575738103 ,105520158098229445 ,106790634767936741 ,126725785273760436 ,130360347839612020 ,133687942926179252 ,141692157734290043 ,143194550664104566 ,160306842597639287 ,173998891843531949 ,183247628716588779 ,184537651297905164 ,186558866388039789 ,188814168372699465 ,216144236503127536 ,232337275735129049 ,247312208703886929 ,279450503710179517 ,282668677772962995 ,309567198492606636 ,311631861404884846 ,331256560022931606 ,347845945233752283 ,366603716795904294 ,383179737489131673 ,396268636465298984 ,397383514531851281 ,397422164057147474 ,411762108364220282 ,421610305962349297 ,432476990719623711 ,434708691791857976 ,438404124415088109 ,438614173718701837 ,453490222739338313 ,478798253541102865 ,490109557864798390 ,490214892555052619 ,493694833659131962 ,503797512382008739 ,506971761952207531 ,507192413749801796 ,541728682469993506 ,542966539237551131 ,547111652835290483 ,550040514385684316 ,554215325115253840 ,561719316556248159 ,574268531123948704 ,578318958170621014 ,586269088216736929 ,610765766128469682 ,617433089249847008 ,621104041168777596 ,622917640848330010 ,640402431534907118 ,649580544250369059 ,658247617172454117 ,663475666724775195 ,664964060575499960 ,670280684237997630 ,686808607695568845 ,689255713823378875 ,694427978495920785 ,700071610482370781 ,700198492159389078 ,700368079049517621 ,709474740040830282 ,712830385911054527 ,712956431336843764 ,714868553685250325 ,730805423088851014 ,732048619727586695 ,742005736583473954 ,744526900766252454 ,752833362690122722 ,758840497256391533 ,773387201502747731 ,780092063655071325 ,783431314481819273 ,800816621603194350 ,817219121483786659 ,818801446757440508 ,833872723602526265 ,839524505994428310 ,841083775409356076 ,842762183607920311 ,847891394133939277 ,860383230291240981 ,868021360115172265 ,883530295008905463 ,884152806362583093 ,885187001833077603 ,909750671986538405 ,918197910554444249 ,926282264602626956 ,953167766835003354 ,956265896376945334 ,960454135658840877 ,972453065227042313 ,975620201065907453 ,989134717870761932 ,993133947365945638 ,996841423688269588 ,1003140657040767467 ,1005315964788740699 ,1041884916760420952 ,1053470990567999064 ,1055784311265051816 ,1064244866636753681 ,1069584410667783034 ,1082511935627893527 ,1086083092943329355 ,1086355499977836291 ,1109833389739671497 ,1112412410255032708 ,1124353535828817149 ,1137858361769935169 ,1140615404884850560 ,1142319918557126253 ,1149006638126401860 ,1160241503178462342 ,1162179523268529971 ,1168083185122723471 ,1178517949637480939 ,1179881637381386274 ,1189768693364504345 ,1192354712588478924 ,1194477613706176902 ,1194792866835879075 ,1199574180488459026 ,1201636820940033830 ,1207436169550209834 ,1213821444744601142 ,1222283748936954558 ,1222517267398638302 ,1223007539523044856 ,1232932073957209033 ,1241018898560619542 ,1264452024080185933 ,1268424036880398688 ,1268726392605090613 ,1297655215519279443 ,1299656013000998619 ,1310180106793430196 ,1310326116964860508 ,1321105045242271458 ,1332146737940089318 ,1350299029747291176 ,1363575611908404428 ,1367647155066517696 ,1374797526684831178 ,1376198828145113171 ,1381894940863607962 ,1391243934651474596 ,1416839459798620798 ,1420558847976826701 ,1427281389558927832 ,1436469245484244946 ,1445023086417095377 ,1452381507065970299 ,1462984966516605890 ,1472536256190811679 ,1477602967021895942 ,1492467558521306517 ,1524992439282241336 ,1552490066117185206 ,1554358135860558093 ,1561372259259031017 ,1569207044262563601 ,1575169788675789676 ,1579784484384534845 ,1591854001398850560 ,1600346194657206710 ,1607413095460223612 ,1611933657462843149 ,1631220440695910599 ,1634393431052495554 ,1655890236217260270 ,1655977976507844106 ,1667575580075527656 ,1670899395671722903 ,1677418286660145806 ,1679983671889887309 ,1724288698910670978 ,1726067799458194256 ,1736667485043934247 ,1737957733234585338 ,1743838607260312953 ,1750307735249741091 ,1758744862699750434 ,1766138630681593813 ,1777804070924229052 ,1777849720016402274 ,1778625465725957907 ,1805711816300128904 ,1815748699086233890 ,1816881523256966276 ,1820553708551441830 ,1831980030817668850 ,1839231299443439305 ,1852937645117459328 ,1855037089152040047 ,1857936411374623656 ,1866547032564663655 ,1880047076042150986 ,1897409351950066983 ,1908036326368983956 ,1921020047841422143 ,1926189812432046965 ,1938143721927680425 ,1941253780376681680 ,1954431945531224605 ,1954602363271876619 ,1956539394925352273 ,1961404932901318608 ,1961850821408733736 ,1991375399253554319 ,1997424138777388703 ,2036831502564921920 ,2045998512975013589 ,2072704353231493483 ,2085203964893255349 ,2089442203890746961 ,2126313516352568442 ,2128279745320404048 ,2131992069383302529 ,2160451107040321247 ,2162644893620721059 ,2172188485953936712 ,2175911443748921952 ,2177136432111904887 ,2178136345579200906 ,2185377459400151843 ,2204577833256879677 ,2212750636063500573 ,2258598356682722129 ,2263323062369915818 ,2282786037898637629 ,2295124930635551071 ,2295714243874726642 ,2295963624111656147 ,2304323421679929041 ,2312301925329056553 ,2313797095859286878 ,2316997201432632299 ,2322372690248581347 ,2326639231450832497 ,2333794856564778735 ,2343143679131393966 ,2353007663706462575 ,2356423945832864722 ,2364281326046102775 ,2370822039389258968 ,2371028271416639984 ,2380883105685589283 ,2391218463466554945 ,2397580610111754980 ,2408698411136846369 ,2409785307893201337 ,2414326736924905085 ,2436931880555020491 ,2467035460261866148 ,2471333052413810802 ,2471605777790972478 ,2478536186862797574 ,2481500998579718073 ,2486437570191059699 ,2488478510946760787 ,2492418007604454220 ,2495720507248134933 ,2496369051363233236 ,2499784437416476901 ,2501633351028960067 ,2509992187466789673 ,2558645264334163767 ,2561809702739741798 ,2590108325835209648 ,2595716926268670191 ,2616097136013433171 ,2624046345660932210 ,2628444773559484498 ,2652473238169429436 ,2666165613289729605 ,2674190890612585517 ,2674421047652362929 ,2675393837459005053 ,2681251702677490071 ,2690164446703551613 ,2698991416108149258 ,2703031689818731866 ,2703134508506834216 ,2715689734313772390 ,2719440076275639532 ,2727843289493918831 ,2729568148693748203 ,2748484207912993084 ,2766798623035267717 ,2769792054529243029 ,2773207362745855518 ,2773555785370530569 ,2777112213822402169 ,2790615423678804567 ,2814499578687607727 ,2834859529201543922 ,2846252467667880573 ,2848636813219469035 ,2854816103474273576 ,2860510342127721188 ,2870303842672678743 ,2872937969283242718 ,2894375320641129162 ,2939024987921926917 ,2946558306644145070 ,2966186523426155486 ,2986295017630157874 ,2995513340833178998 ,2998453117889656559 ,3013572086178376903 ,3024728421438774678 ,3037556824202989066 ,3038647833785264173 ,3062603540632623879 ,3062868262927783540 ,3067357747787616072 ,3079627062062778989 ,3092364138048580783 ,3108892547856942219 ,3119368632640901487 ,3122709648198982315 ,3124184224693616505 ,3127571047359013270 ,3128990177553234172 ,3131186887138493993 ,3151885898800719441 ,3180986339973214622 ,3191554136743886180 ,3194038436675622777 ,3219314412279305688 ,3230039090470452788 ,3233650152770691005 ,3248112822121895912 ,3248651646366905625 ,3251228265491234731 ,3261636661994828969 ,3269173163606337923 ,3276861783317853109 ,3285645716515365489 ,3290663967568247589 ,3305388947118672677 ,3308115888679555753 ,3310428621216916606 ,3316001377660979229 ,3321455392985641130 ,3327464201842816544 ,3328844371486621987 ,3373312633830342508 ,3373650138372958703 ,3378296315258522162 ,3379053856465555779 ,3385837975241182673 ,3402569986985638286 ,3409006584048343469 ,3412725715615180466 ,3431234134606187757 ,3446520473031930698 ,3453922464932641491 ,3455571205019968715 ,3464483622416218987 ,3471432734728942294 ,3481380709818973304 ,3512216860318507810 ,3513085746795888659 ,3519059975352954302 ,3520858683029543285 ,3534462892575149544 ,3538823503076168092 ,3544361956578057566 ,3548251707155311829 ,3551192138702371737 ,3553877259515517657 ,3575064529021879408 ,3584200337866321387 ,3587081386403366968 ,3589695125359558289 ,3597901888481322224 ,3625118180899342410 ,3628998518983425671 ,3635971761407256367 ,3642949024406167066 ,3653274746820363691 ,3662703964625903997 ,3672175824577956430 ,3684675305784037623 ,3689827759795829552 ,3703525328816669485 ,3717949322591913036 ,3732802042870489397 ,3749507458712087035 ,3798342136880624190 ,3802499147428943793 ,3804781836005976017 ,3846640548434991832 ,3850870618012393082 ,3864587310851260771 ,3867938975015061832 ,3879625526201128295 ,3903542450119116437 ,3908118978148418994 ,3914275093050712660 ,3917542374345696784 ,3921530217716484435 ,3938855528369129388 ,3939511912548479726 ,3941433419939347873 ,3959758881372996218 ,3980022254324613572 ,3980434295234995911 ,3991741277490503147 ,3993421924468456936 ,3995389723602719761 ,4007642698898110644 ,4010012987650851126 ,4012209440485006844 ,4023317741201098383 ,4049275989171697612 ,4058853623612916997 ,4059531420490317122 ,4067556302878172082 ,4085063896826380257 ,4102083480239625795 ,4105248925845982147 ,4110884562441064513 ,4113564596909422958 ,4117547319491899284 ,4119036841397236890 ,4129996681461882491 ,4131410147832403483 ,4132715883440590893 ,4156081266860256769 ,4163159926728816824 ,4182118321447513173 ,4192406154081239148 ,4200570204482860312 ,4200986846420241518 ,4201046770582176058 ,4204081405608005669 ,4204617162867996817 ,4208241063686473162 ,4210575001758066146 ,4224409930840340022 ,4254729914391100295 ,4258906794679066849 ,4264718231413458120 ,4278074928511534524 ,4278564166613167462 ,4279790094891434999 ,4284742350171740899 ,4289505692306179089 ,4290673817964371777 ,4314782572674441731 ,4316600144740363480 ,4324082113379321048 ,4332247863400671535 ,4353863171702507198 ,4372560714482589211 ,4375891136630716905 ,4388674057041553425 ,4402691606739820352 ,4406646490160420795 ,4428160092129514228 ,4438072310216053982 ,4439218188486898942 ,4443017185976325082 ,4449293082409128988 ,4450403438892987928 ,4469827509453376961 ,4481499789120971044 ,4483877185319075552 ,4507988895610620675 ,4512201699733648694 ,4528484364480468048 ,4540849445249967074 ,4551011755070860175 ,4575960733625677542 ,4578108383990519538 ,4578452359698557130 ,4579282226262097952 ,4585842274716758393 ,4593690414861980333 ,4599832236199495964 ,4601175320063707498 ,4604018570696665261 ,4611316160464425889 ,4614268471836276349 ,4619014702007964559 ,4651957922931774751 ,4674324548251192424 ,4688529627252974505 ,4699653245383690916 ,4715593530325657937 ,4716748765669408574 ,4720104792189287863 ,4723396921085150412 ,4733202088434485112 ,4737396139133090722 ,4738207026737512750 ,4751909368413470669 ,4757919449342870155 ,4778154280673291690 ,4784763357623694734 ,4785215232455538038 ,4790354653183676183 ,4822551056553997269 ,4825492841732684014 ,4825508602489217045 ,4834187206360047211 ,4839525055535581147 ,4859156787931883081 ,4865109117175013114 ,4868526179111648554 ,4877344933343802384 ,4884290455933024463 ,4887941025851770936 ,4889464868025050357 ,4900325986078622311 ,4904826935092100156 ,4915428920298043219 ,4924254049638783213 ,4927124626697802686 ,4953320300970081794 ,4962635455617260005 ,4966327684607592617 ,4969012366101483622 ,4974629979163356471 ,4982198462989298154 ,4996739762899306905 ,4999476928961506784 ,5006572088982977753 ,5028154479904532221 ,5028434590891048323 ,5044534531475880181 ,5045043954266331340 ,5053808835607364962 ,5054320718641654200 ,5073498744546696557 ,5080467306563346740 ,5083190564879676574 ,5086596056765390861 ,5103145452730510270 ,5104928525148173136 ,5128699051355154613 ,5130351441567240192 ,5144709791233287100 ,5155873452374651032 ,5163172388268828422 ,5206463495145902611 ,5215681543558157718 ,5217226351799005716 ,5222546102553352515 ,5236364792963300195 ,5240150358005658429 ,5247242315026964089 ,5252615224476276872 ,5257261196281171879 ,5257584114386148998 ,5261409186197000347 ,5265810942938648001 ,5266917319305138679 ,5274207356317246477 ,5275610032533004989 ,5283947340769486937 ,5285180272580977637 ,5288989243224726675 ,5303186934625915738 ,5303971180269843465 ,5325745307075910243 ,5344854250542694047 ,5349757422303665493 ,5377749667336931258 ,5384536610563640659 ,5411654285708352148 ,5430451364650611533 ,5432129779793828343 ,5437333365904910947 ,5445179301043285373 ,5447545317393214441 ,5448918302355174342 ,5455016047648379510 ,5466816763514921450 ,5467494157460007482 ,5469622212473014772 ,5472151721657492767 ,5475791582010979089 ,5479754660902080842 ,5479883080074501143 ,5501974927270829430 ,5511806482328665390 ,5512321254810989281 ,5513414734889473389 ,5516661439412188119 ,5529026437429147896 ,5529562732724957576 ,5534521387281464706 ,5561540091548602147 ,5573707811411995747 ,5625522188591022315 ,5637252821535195227 ,5667111101832090055 ,5690396420508297277 ,5697738801291201084 ,5699273208568965252 ,5712026702923841940 ,5752600578999199125 ,5756222309521224241 ,5767312902193739147 ,5783043754722083607 ,5792766860229243157 ,5814086039248051486 ,5822453164763914979 ,5826580058564224566 ,5828064601862790237 ,5828444415959219911 ,5841236051851964455 ,5844507470348209681 ,5850123871619281685 ,5858921991928356564 ,5873323640919026933 ,5879670602083440194 ,5899569819961695237 ,5908042594234786936 ,5914935379697214701 ,5922745185490416542 ,5971524614168834596 ,5980409390380073290 ,5992847832144821469 ,6000002442161044729 ,6007058212602969154 ,6020908829558918070 ,6025076966704965226 ,6038010282810725870 ,6061018870516585279 ,6061280441030962302 ,6062965561231088663 ,6068900233782171117 ,6089965358881090344 ,6095906517396636419 ,6105519806172793651 ,6120050760344130354 ,6135568648393244342 ,6145757910228390865 ,6159616645604734884 ,6164826854995090810 ,6166206880166490056 ,6182698259869128424 ,6203329423857431814 ,6203979389144691874 ,6207794315172231894 ,6207888184305534953 ,6210246944904728530 ,6218229635088792359 ,6245841221012301492 ,6246663334943624617 ,6253524869158227814 ,6266562865663905789 ,6274312698828969347 ,6288881974490814243 ,6291999921015726198 ,6294581447570801766 ,6310836128127146109 ,6313879065096237454 ,6320843531848251091 ,6323745265974812780 ,6339090855206915377 ,6341086661720158875 ,6341543601139605927 ,6357341135425037619 ,6361448613629544435 ,6368055405337441388 ,6372397130901572487 ,6375023134594813667 ,6376473878289668788 ,6387284101232844351 ,6388237172858495609 ,6389197068270665391 ,6390543529242047506 ,6411100786961348199 ,6425074926255681606 ,6438526886527321142 ,6451065722852589740 ,6455720993530657935 ,6465163575704658931 ,6475653105719590980 ,6486255917428281840 ,6486592692765654919 ,6518008879872573533 ,6526907951971110051 ,6528348674192067598 ,6532782505146399394 ,6538798068028916670 ,6549331068542862091 ,6554660526282242961 ,6565962228775982948 ,6576654383472840714 ,6593644398881070547 ,6604329500941272238 ,6616836923511648062 ,6622726137699888871 ,6633347070757199897 ,6641067902632735549 ,6652657354088191591 ,6662355438840380608 ,6675838775591743046 ,6688642410855226094 ,6692788423989924015 ,6696664112413568635 ,6697171243956195944 ,6706691813704814088 ,6711312250016637666 ,6711456094157674625 ,6746372420415521017 ,6751119339670044375 ,6759808065083819640 ,6768440609832461097 ,6778881914564352531 ,6784285788415884008 ,6784920890099469105 ,6786167381118215086 ,6810899017280500150 ,6825703879112724896 ,6828489965650169463 ,6842956203685790643 ,6849750734760554874 ,6858192570499332753 ,6860242279621123568 ,6870927217057685494 ,6881806329985661933 ,6901171768008068639 ,6920790168481292722 ,6926162650406931162 ,6934663091774917613 ,6966616560332531222 ,6971524019633747916 ,6975393203894651185 ,6976620425922205062 ,6995270718933870857 ,6998529694413212986 ,7005149550634057235 ,7032250796138001431 ,7051020232666447594 ,7070348618891649245 ,7073236092240397980 ,7087474051439667629 ,7088132447461740664 ,7089399507622030047 ,7098222687106493424 ,7103286397037497016 ,7120901661556465012 ,7131457190770755175 ,7138531186871362929 ,7157748190374205255 ,7168955765006747550 ,7187945943600896313 ,7220801227389723489 ,7226459633352533419 ,7234232385861674491 ,7245499949374539647 ,7245878545768396276 ,7247178468504400707 ,7248674249285892145 ,7259606884723494626 ,7276967138560723600 ,7286693710940895317 ,7316132856977341747 ,7320116210274391678 ,7322752100084492932 ,7323337570565168060 ,7324746298035482583 ,7325211530108294800 ,7328973719877410240 ,7338966267712858795 ,7353771658908653483 ,7357094208739462900 ,7362183107053163565 ,7375021491826472207 ,7390417062441453892 ,7407793533253806436 ,7414141271230379059 ,7417023701672175953 ,7425224185416642542 ,7430965201739863984 ,7449602979309409682 ,7465843479402623526 ,7470446847512076864 ,7519826851572795742 ,7520223184762425724 ,7526109954963209350 ,7529955234664378932 ,7544718600125797668 ,7546955296597159745 ,7550542540642063266 ,7556151287307770964 ,7572780139130889427 ,7573637054356269936 ,7575855970988350249 ,7583679746375145622 ,7584527760525274062 ,7593942669177226898 ,7598016590404434193 ,7609613388371519015 ,7612168863269462545 ,7671176721880274850 ,7673539922642125819 ,7679352498118812418 ,7691294627715182854 ,7696184432839177745 ,7723735176375105939 ,7724621291647237139 ,7727565391141340116 ,7746775975928182077 ,7756354652053524776 ,7758318319080909787 ,7762342225389379768 ,7773762331464447160 ,7774978188884092843 ,7775538674046874749 ,7790025552713805273 ,7793169646143456362 ,7798439476371227708 ,7807068238645219351 ,7817028265118359491 ,7852125464451579621 ,7860614435196623037 ,7863276816204634388 ,7892595598682043913 ,7898092937560216206 ,7938775739890147757 ,7941886291527769261 ,7945272097686273883 ,7946842846301940606 ,7952625067452210969 ,7961999395316284488 ,7968811793045636651 ,7976168148618274348 ,7979322836649397113 ,7983781287385929376 ,7985986099020229827 ,7994435298528848171 ,8002342720228373885 ,8019002426294303390 ,8028565639632533498 ,8029998398876722788 ,8060096272761884188 ,8064314130551119376 ,8086548441608477671 ,8090661506210584758 ,8110659677756843774 ,8150895769816679179 ,8152182302931845072 ,8169855826341935791 ,8173426976815470008 ,8178968679524788646 ,8181550013460035416 ,8194353463404481151 ,8196169703569107305 ,8196283415332543020 ,8197287585854415797 ,8202558576921795314 ,8222826009730560735 ,8223014608940135281 ,8235568466217255012 ,8240409668009302375 ,8247204619923547153 ,8249312772924916384 ,8251281117656825318 ,8264403481747379486 ,8264529693655468463 ,8284653000675016575 ,8308100265942615022 ,8314578597796281613 ,8319066920589754779 ,8331566149736031966 ,8337462714761734681 ,8352713355229278433 ,8358527927577707610 ,8363333927319917142 ,8363568485849988308 ,8368342672201927034 ,8378382180374681696 ,8382965066779493696 ,8395485479139826163 ,8397248840417951515 ,8397616463971828419 ,8399185835454773737 ,8408493314349419055 ,8412344624740271376 ,8416166681302417612 ,8422591201352487186 ,8427126288999118101 ,8438611698532031346 ,8451056108006997664 ,8460444095765662895 ,8464620818025072844 ,8490901654066116993 ,8512997257411163496 ,8523029408463561458 ,8526677574580238320 ,8549678492290503542 ,8568570643927905098 ,8568974794872278061 ,8569464731876687205 ,8576270164613469537 ,8582150597043416576 ,8594438338791164101 ,8596627956907685099 ,8596819957265972255 ,8609066074048126096 ,8609862389189217110 ,8611147187772583011 ,8611300570089567501 ,8616216615241596277 ,8626966818497600342 ,8631895158813343632 ,8635208147854637401 ,8638102517692409625 ,8644093748768073919 ,8646144585554669936 ,8652358166612387516 ,8666338247257362925 ,8678889938004733047 ,8697880808534648051 ,8711219003715779900 ,8724439370632375434 ,8733561548089148520 ,8744135792113805625 ,8752956056890276528 ,8753611162420011834 ,8757169056062213825 ,8761601573907667106 ,8775465485326091005 ,8779346095206129383 ,8786516618252516863 ,8792153185286515342 ,8796451395514848366 ,8796652749770306973 ,8798895526561111931 ,8810822768219843604 ,8815062068035238008 ,8827409973529228929 ,8839515535114614864 ,8844000680146746838 ,8844620839008095951 ,8849490426734466528 ,8869563738726038749 ,8875055140394144476 ,8909402153907881911 ,8919105881074602790 ,8923433518585864244 ,8926023083761929107 ,8938857023592560799 ,8940398910258671194 ,8956919655941811412 ,8986323567437230528 ,8994953876118603072 ,9006934523211617454 ,9020561999749499777 ,9021378075205165650 ,9041082738215043423 ,9050065047088399815 ,9052458396887115950 ,9066144357470681228 ,9066488910686761760 ,9068989028910357541 ,9073955118528719756 ,9074819987035809696 ,9082938547123669584 ,9107837036436401756 ,9121536437298966801 ,9128456735885098947 ,9133523713643539077 ,9143350527252468296 ,9157151019407898919 ,9159200157893265243 ,9168424097916988973 ,9174446334846049093 ,9194280740311927634 ,9197865792886346794 ,9207485739897662565 ,9212834820444476574 ,9222016352643136925
};

template <typename StructT, typename F, F f>
void RunBenchmark( const std::vector<ll>& vals, const std::vector<int>& indexes, StructT& s, TestStats& ts) {
  //void RunBenchmark( const std::vector<std::tuple<ll, int> >& order, const StructT& s, TestStats& ts) {
  unsigned A;

  const ll nNums = vals.size();

  //int nEq = 0;
  int sumSteps = 0;
  ll nIx = 0;
  ll st = __rdtsc();
  for (int i = 0; i < nNums; i++) {
#ifndef NDEBUG
    printf("\n%d", indexes[i]);
#endif
    Search r = f(vals[i], s);
    nIx += r.ix;
    //bool eq = r.ix == indexes[i];
    //    sumSteps += r.steps1;
    //nEq += eq;
#ifndef NDEBUG
    if (r.ix != indexes[i]) {
      printf("a[%d]=%ld <> %d\n", indexes[i], vals[i], r.ix);
      assert(r.ix == indexes[i]);
    }
#endif
  }
  ll dt = __rdtscp(&A) - st;
  ts.runStats.push_back(RunStats{sumSteps});
  ts.cyclesByIx.push_back(std::make_tuple(dt, ts.cyclesByIx.size()));
  if (nIx != nNums * (nNums - 1) / 2)
    printf("mess up\n");
  //printf("%s %llu steps, %d %llu \n", ts.name.c_str(), sumSteps, maxSteps, maxStepV);
  //  if (nEq != (int)nNums)
  //    printf("%d < %llu matched\n", nEq, nNums);
}


unsigned lg(unsigned x) {
  assert(x >= 2); // subtracting and clz < 1 is undefined.
  return 32 - __builtin_clz(x-1);
}

unsigned lg_flr(unsigned x) {
  assert(x >= 1);
  return 32 - __builtin_clz(x);
}

inline unsigned lgl(uint64_t x) {
  assert(x >= 2); // subtracting and clz < 1 undefined
  return 64 - __builtin_clzll(x-1);
}

inline int lgl_flr(uint64_t x) {
  assert(x >= 1); // clz < 1 undefined
  return 64 - __builtin_clzll(x);
}

// https://locklessinc.com/articles/sat_arithmetic/
inline ll sub_sat_u64(ll x, ll y) {
  ll res = x-y;
  res &= -(res <= x);
  return res;
}

template <int LG_N>
struct DivLut {
  typedef __uint128_t DT; // double T
  typedef uint64_t T;

  const static int N = 1 << LG_N;
  DivLut() {
    memset(pT, 0, sizeof(pT[0]) * N);
    memset(lg_qT, 0, sizeof(lg_qT[0]) * N);

    // I've moved everything back by one to accomodate common case

    // multiplying by one is approximated by (2^64 - 1) / 2^64
    pT[1-1] = ~(T)0;
    lg_qT[1-1] = 0;

    // do powers of 2
    // start at zero since we multiply by 2^64 / 2
    for (int i = 2, j = 0; i <= N; i*=2, j++) {
      pT[-1+i] = (T)1 << 63;
      lg_qT[-1+i] = j;
    }

    // generate fast multiply results
    for (int i = 1; i <= N; i++) {
      int d = i;
      int lg_q = 0;
      // reduce to an odd number
      while (pT[-1+d] == 0 && d % 2 == 0) {
        d /= 2;
        lg_q++;
      }
      if (pT[-1+d] != 0) {
        pT[-1+i] = pT[-1+d];
        lg_qT[-1+i] = lg_qT[-1+d] + lg_q;
        continue;
      }

      // find a 2^n + 1 multiple
      int j = 64;
      for (; j < 64+lgl(d); j++) {
        DT x = ((DT)1 << j) + 1;
        int r = x % d;
        if (r == 0) {
          pT[-1+i] = (((DT)1 << j) + d) / d;
          lg_qT[-1+i] = lg_q + (j - 64);
          break;
        }
      }
      if (pT[-1+i] == 0) {
        pT[-1+i] = (((T)1 << 63) / d) << 1;
        // guaranteed i > 1, so we will always have room to shift left
        // we always divide by 2^64, so we have to make sure that's happening
        lg_qT[-1+i] = lg_q;
      }
    }
  }

  T div(T n, T d) {
    d--; // start the d-1 early
    if (d > N-1) {
      // note that this becomes ceiling log
      const int k = lgl_flr(d) - LG_N;
      const T pIx = d >> k; // 1 + (d-1) >> k, but we started d, and -1 for index
      return divFit(n, pT[pIx], k + lg_qT[pIx]);
    } else {
      return divFit(n, pT[d], lg_qT[d]);
    }
  }

  void one_d(const T d, T& p, int& lg_q) const {
    if (d > N) {
      const int k = lgl_flr(d) - LG_N;
      ll pIx = (d-1) >> k;
      p = pT[pIx];
      lg_q = k + lg_qT[pIx];
    } else {
      p = pT[d];
      lg_q = lg_qT[d];
    }
  }

  T divFit(T n, T p, int lg_q) {
    // assuming that we're in the range
    T hi = ((DT)n * p) >> 64;
    return hi >> lg_q;
  }

  T pT[N];
  int lg_qT[N];
};
template <int LG_N>
struct DivLut3 {
  typedef __uint128_t DT; // double T
  typedef uint64_t T;

  const static int N = 1 << LG_N;
  DivLut3() {
    memset(pT, 0, sizeof(pT[0]) * N);

    // counting on lg_q being small enough that we can shift right

    // I've moved everything back by one to accomodate common case

    // multiplying by one is approximated by (2^64 - 1) / 2^64
    pT[1-1] = ~(T)0;

    // do powers of 2
    // start at zero since we multiply by 2^64 / 2
    for (int i = 2, lg_q = 0; i <= N; i*=2, lg_q++) {
      T p = (T)1 << 63;
      p = p >> lg_q;
      pT[-1+i] = p;
    }

    // generate fast multiply results
    for (int i = 1; i <= N; i++) {
      int d = i;
      int lg_q = 0;
      // reduce to an odd number
      while (pT[-1+d] == 0 && d % 2 == 0) {
        d /= 2;
        lg_q++;
      }
      if (pT[-1+d] != 0) {
        if (i == d) continue;
        pT[-1+i] = pT[-1+d] >> lg_q;
        continue;
      }

      // find a 2^n + 1 multiple
      int j = 64;
      for (; j < 64+lgl(d); j++) {
        DT x = ((DT)1 << j) + 1;
        int r = x % d;
        if (r == 0) {
          lg_q = lg_q + (j-64);
          pT[-1+i] = ((((DT)1 << j) + d) / d) >> lg_q;
          break;
        }
      }
      if (pT[-1+i] == 0) {
        pT[-1+i] = ((((T)1 << 63) / d) << 1) >> lg_q;
      }
    }
  }

  T div(T n, T d) {
    d--; // start the d-1 early
    if (d > N-1) {
      // note that this becomes ceiling log
      const int k = lgl_flr(d) - LG_N;
      const T p = d >> k; // +1 for math, -1 for offset
      return divFit(n, p) >> k;
    } else {
      // -1 for index adjustment + 1 for early adjustment
      return divFit(n, d); 
    }
  }

  T divFit(T n, T p) {
    assert(p <= N);
    // assuming that we're in the range
    return ((DT)n * pT[p]) >> 64;
  }

  T pT[N];
};

DivLut<8> dL;
DivLut3<8> dL2;

struct BinStruct {
  BinStruct(const std::vector<ll>& _a) : a(_a) {  }

  const std::vector<ll> a;
};

struct IntStruct {
  IntStruct(const std::vector<ll>& _a) : a(_a) {
    lgScale = lg(a.size() - 1);
    ll tR = a.size() - 1;
    ll rSc = __builtin_clz(r);
    r2 = tR << rSc;
    lg_d2 = lgl(a.back() - a.front()) + rSc - 64;
    lg_d = lgl(a.back() - a.front()) - lgScale;
    yLS = a.front() >> lgScale;
    ll d = (a.back() - a.front()) >> lgScale;
    dL.one_d(d, p, lg_q);
  }

  unsigned lgScale;
  unsigned lg_d;
  unsigned lg_d2;
  ll r;
  ll r2;
  ll yLS;
  ll p; int lg_q;
  const std::vector<ll> a;
};

struct IntStructT {
  IntStructT(const std::vector<ll>& _a) : array(_a) {
    lgScale = lg(a.size() - 1);
    a.push_back(_a[0] >> lgScale);
    for (int i = 1; i < _a.size(); i++) {
      a.push_back(_a[i] >> lgScale);
      assert(_a[i] == _a[i-1] || (_a[i] >> lgScale) > (_a[i-1] >> lgScale));
    }
  }

  unsigned lgScale;
  std::vector<ll> a;
  const std::vector<ll> array;
};

struct OracleStruct {
  // note that to ensure fast code, offset is always to the left, which means that offset searches wont have the full offset
  OracleStruct(const std::vector<ll>& _a, const std::vector<int>& _i, const int offset = 0, const bool rnd = false) : a(_a), j(0) {
    // easier to make a single long pipeline instead of a branch
    // There's blocking on the output to be produced, instead of being able to go through the steady state throughput
    // You may end up paying the latency cost multiple times instead of just once with left-deep
    // single relation plan because only one table in FROM clause
    for (int ti : _i) {
      int tti = ti;
      if (rnd && ((rand() % 2) == 0)) {
        tti += offset;
      } else {
        tti -= offset;
      }
      unsigned r = a.size() - 1;
      tti = tti < 0 ? 0 : tti;
      tti = tti > r ? r : tti;
      i.push_back(tti);
    }
  }

  const std::vector<ll> a;
  std::vector<int> i;
  int j;
};

Search bsPVKEq2(const ll x, const BinStruct& s) {
  const std::vector<ll>& array = s.a;
  const int MIN_EQ_SZ = 2;
  int leftIndex = 0;                                                               
  int n = array.size();                                                            
  int half;
  while ((half = n) > MIN_EQ_SZ) {
    half /= 2;
    n -= half;
    leftIndex = array[leftIndex + half] <= x ? leftIndex + half : leftIndex;
  }
  while ((half = n) > 1) {
    half /= 2;
    n = array[leftIndex + half] == x ? 0 : n - half;
    leftIndex = array[leftIndex + half] <= x ? leftIndex + half : leftIndex;
  }                                                                                
  assert(array[leftIndex] == x);  
  return Search{leftIndex};
}

Search is(const ll y, const IntStruct& s) {
  const std::vector<ll>& a = s.a;
  ll l = 0, r = a.size() - 1;
  assert(r - l >= 0); // assume non-empty vector
  ll yR = a[r], yL = a[l];
  const unsigned lgScale = s.lgScale;
  ll n = (r-l)*((y-yL) >> lgScale);
  ll d = ((yR - yL) >> lgScale);
  ll m = l + dL.div(n,d);
#ifndef NDEBUG
  printf(" %ld", m);
#endif
  assert(m <= r);
  assert(m >= l);
  assert(a[m] >= a[l]); // we know this because n would've been less than d
  if (a[m] > y) {
    do { m--; } while (a[m] > y);
    return Search{(int)m};
  }

  // n < d implies that we should start from the left
  // we know that l = m because we didn't go into the only path ewhere that's not true
  // note that (a[m] < y && a[m] < yR) was better than (a[m] < y && m < yR).
  if (y >= yR) return Search{(int)r};
  while (a[m] < y) m++;
  return Search{(int)m};
}

Search is2(const ll y, const IntStruct& s) {
  const std::vector<ll>& a = s.a;
  ll l = 0, r = a.size() - 1;
  assert(r - l >= 0); // assume non-empty vector
  ll yR = a[r], yL = a[l];
  const unsigned lgScale = s.lgScale;
  ll n = (r-l)*((y-yL) >> lgScale);
  ll m = l + dL.divFit(n,s.p, s.lg_q);

#ifndef NDEBUG
  printf(" %ld", m);
#endif
  assert(m <= r);
  assert(m >= l);
  assert(a[m] >= a[l]); // we know this because n would've been less than d
  if (a[m] > y) {
    do { m--; } while (a[m] > y);
    return Search{(int)m};
  }

  // n < d implies that we should start from the left
  // we know that l = m because we didn't go into the only path ewhere that's not true
  // note that (a[m] < y && a[m] < yR) was better than (a[m] < y && m < yR).
  if (y >= yR) return Search{(int)r};
  while (a[m] < y) m++;
  return Search{(int)m};
}

Search is3(const ll y, const IntStruct& s) {
  typedef __uint128_t u128;

  const std::vector<ll>& a = s.a;
  ll l = 0, r = a.size() - 1;
  assert(r - l >= 0); // assume non-empty vector
  ll yR = a[r], yL = a[l];
  ll n = ((u128)s.r2 * (y-yL)) >> 64;
  ll m = l + (n >> s.lg_d2);
#ifndef NDEBUG
  printf(" %ld", m);
#endif
  assert(m <= r);
  assert(m >= l);
  assert(a[m] >= a[l]); // we know this because n would've been less than d
  if (a[m] > y) {
    do { m--; } while (a[m] > y);
    return Search{(int)m};
  }

  // n < d implies that we should start from the left
  // we know that l = m because we didn't go into the only path ewhere that's not true
  // note that (a[m] < y && a[m] < yR) was better than (a[m] < y && m < yR).
  if (y >= yR) return Search{(int)r};
  while (a[m] < y) m++;
  return Search{(int)m};
}

Search oracle(const ll y, OracleStruct& s) {
  int i = s.i[s.j++];
  s.j = s.j >= s.i.size() ? 0 : s.j;
  return Search{i, 0}; //, 1
}

int main() {
  // lg only supports [2, 2^32-1]
  assert(lg(2) == 1);
  assert(lg(3) == 2);
  assert(lg(4) == 2);
  assert(lg(17) == 5);
  assert(lg(31) == 5);
  assert(lg(32) == 5);
#ifndef NDEBUG
  assert(0 < printf("log tests pass\n"));
#endif

  // TESTS Div
#ifndef NDEBUG
  if (dL.div(0xFFFULL, 2) != 0x7FFULL) {
    printf("0xFFF / 2 != %lx\n", dL.div(0xFFFULL, 2));
    assert(dL.div(0xFFFULL, 2) == 0x7FFULL);
  }
#endif

  int nNums;
  std::vector<ll> searchVal;
  std::vector<int> searchIndex;

  {
    std::vector<std::tuple<ll, int> > search;

    bool loaded = 1 == scanf("%d", &nNums); (void)loaded; // silence not used
    assert(loaded);
    if (nNums!=0) {
      input.clear();
      for (int i = 0; i < nNums; i++) {
        ll x;
        loaded = 1 == scanf("%ld", &x);
        assert(loaded);
        input.push_back(x == 0 ? 1 : x); // temporary measure to keep from div by 0
      }
    } else {
      nNums = input.size();
    }
    for (int i = 0; i < nNums; i++) {
      search.emplace_back(input[i], i);
    }
    std::srand(10);
    std::random_shuffle(search.begin(), search.end());
    for (int i = 0; i < nNums; i++) {
      ll x; int ix;
      std::tie(x, ix) = search[i];
      searchVal.push_back(x);
      searchIndex.push_back(ix);
    }
  }

  IntStruct isS(input);
  BinStruct bsS(input);
  OracleStruct oS(input, searchIndex, 0);
  // must seed first
  OracleStruct oS5(input, searchIndex, 5, true);


  typedef TestStats TS;
  //using BsFn = Search (*)(const ll, const BinStruct&);
  using IsFn = Search (*)(const ll, const IntStruct&);
//  using OsFn = Search (*)(const ll, OracleStruct&);


  //std::vector<TS> tests = { TS{"bsPVKEq2"}, TS{"is2"}
  //  std::vector<TS> tests = { TS{"is"}
  std::vector<TS> tests = {
#ifndef REVERSE
//    TS{"is   "}
    TS{"is2  "}
//    TS{"oracl"},
#else
    TS{"is2  "}
    ,TS{"is   "}
#endif
    //      TS{"bs   "}, TS{"is   "}
    //     ,TS{"bs   "}, TS{"is2  "}
    //     ,TS{"bs   "}, TS{"is2  "}
    //
    //     ,TS{"bs   "}, TS{"is2  "}
    //     ,TS{"bs   "}, TS{"is   "}
  };
  //const int N_RUNS = 1 << 5;
#ifndef NDEBUG
  const int N_RUNS = 1 << 1;
#else
  const int N_RUNS = 1000 * (1 << 19) / nNums;
#endif
  time_t lastTime = time(NULL);

  for (int i = 0; i < N_RUNS; i++) {
    time_t nowTime = time(NULL);
    if (nowTime != lastTime) {
      fprintf(stderr, "%d ", i);
      lastTime = nowTime;
    }
    int testIx = 0;
#ifndef REVERSE
//    RunBenchmark<IntStruct, IsFn, is >(searchVal, searchIndex, isS, tests[testIx++]);
    RunBenchmark<IntStruct, IsFn, is2 >(searchVal, searchIndex, isS, tests[testIx++]);
//    RunBenchmark<OracleStruct, OsFn, oracle >(searchVal, searchIndex, oS, tests[testIx++]);
#else
    RunBenchmark<IntStruct, IsFn, is2 >(searchVal, searchIndex, isS, tests[testIx++]);
    RunBenchmark<IntStruct, IsFn, is >(searchVal, searchIndex, isS, tests[testIx++]);
#endif

    assert((size_t)testIx == tests.size());
  }
  fprintf(stderr, "\n");
  bool first = true;
  for (auto& t : tests) {
    printf("%s%s", true != first ? "," : "", t.name.c_str());
    std::sort(t.cyclesByIx.begin(), t.cyclesByIx.end());
    first = false;
    assert(t.cyclesByIx.size() == N_RUNS);
    //printf("*** %s,%d ****\n", t.name.c_str(), t.runStats[0].sumSteps1);
  }
  for (int i = 0; i < N_RUNS && i < 10; i++) {
    first = true;
    printf("\n");
    for (auto& ts : tests) {
      printf("%s%ld", true != first ? "," : "", std::get<0>(ts.cyclesByIx[i]));
      first = false;
    }
  }
  printf("\n");
}
